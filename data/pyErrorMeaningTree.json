{
"type": "errorType",

"SyntaxError": {
    "type": "errorMessage",
    "var": "msg",

    "EOL while scanning string literal": "guillemetsError",
    "Non-ASCII character .* in file .* but no encoding declared; .*": "nonAscii",
    "'return' outside function": "returnOutsideFct",
    "^Missing parentheses in call to '(.*)'$": {
        "typeError": "missingParentheses",
        "params": ["msg[1]"]
    },
    ".*": [
        {
            "condition": "errorLine_openBracket > 0",
            "block": {
                "typeError": "previousErrorBrackets",
                "realErrorLine": "getLineFirstBracketOfError()"
            },
            "else": {
                "condition": "code.countOpenCloseBrackets != 0",
                "block": "errorBrackets"
            }
        },
        {
            "condition": "code.isConditianal",
            "block": {
                "type": "errorCodeLine",
                ".*[^=<>]=[^=<>].*": "conditionOneEqual",
                ".*=>.*": "plusGrandEgalInversion",
                ".*=<.*": "plusPetitEgalInversion"
            }
        },
        {
            "type": "errorCodeLine",
            ".*;[[:blank:]]*": "pointVirguleFin",
            "\\s*(\\w)+\\s+(\\w)+\\s*=.*": "typeVariableDeclaration"
        },
        {
            "condition": "NOT code.endByTwoPoints",
            "block": {
                "condition": "code.isStruct",
                "block": {
                    "regexOn": "code.getFirstWord()",
                    "for":  "deuxPointsFor",
                    "if":  "deuxPointsIf",
                    "elif":  "deuxPointsElif",
                    "else":  "deuxPointsElse",
                    "def":  "deuxPointsDef",
                    "while":  "deuxPointsWhile"
                }
            }
        }
    ],
    "default": "invalidSyntax"
},
"IndentationError": {
    "type": "errorMessage",
    "expected an indented block": "indentationErrorEmptyBlock",
    "unindent does not match any outer indentation level": "indentationErrorLevel",
    "default": "indentationError"
},
"ValueError": {
    "type": "errorMessage",
    "var": "msg",

    "math domain error": {
        "typeError": "mathDomainError",
        "concatenate": [{
            "type": "errorCodeLine",
            ".*log.*": "mathDomainError_log"
        }, {
            "type": "errorCodeLine",
            ".*sqrt.*": "mathDomainError_sqrt"
        }]
    },
    "invalid literal for int\\(\\) with base [[:digit:]]*: '(.*)'": {
        "regexOn": "msg[1]",
        "([[:blank:]]*-?[[:d:]]+[[:blank:]]*)+": "valueErrorIntMappage",
        "[[:blank:]]*-?[[:d:]]+\\.[[:d:]]+[[:blank:]]*": "valueErrorIntInsteadOfFloat",
        "default": "valueErrorInt"
    }
},
"NameError": {
    "type": "errorMessage",
    "var": "msg",

    "name '(.*)' is not defined": {
        "typeError": "undefinedVar",
        "params": ["msg[1]"]
    }
},
"IndexError": "indexError",
"KeyError": "KeyError",
"ZeroDivisionError": "ZeroDivisionError",
"ImportError": "ImportError",
"EOFError": "EOFError",
"TypeError": {
    "type": "errorMessage",
    "var": "msg",

    "'int' object is not subscriptable": {
        "typeError": "IntNotSubscriptable"
    },

    "'int' object does not support item assignment": {
        "typeError": "IntNotSubscriptable"
    },

    "unsupported operand type... for ([^:]*): '(.*)' and '(.*)'": {
        "typeError": "UnsupportedOperand",
        "params": ["msg[1]", "msg[2]", "msg[3]"]
    }
},
"RuntimeError": {
    "type": "errorMessage",
    "var": "msg",

    "maximum recursion depth exceeded": {
        "typeError": "MaximumRecursion"
    }
}
}
